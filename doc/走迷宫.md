## 走迷宫

### 题目描述
```C++
有一个n*m格的迷宫(表示有n行、m列)，其中有可走的也有不可走的，如果用1表示可以走，0表示不可以走，文件读入这n*m个数据和起始点、结束点(起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号)。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息(用-l表示无路)。
请统一用 左上右下的顺序拓展，也就是 (0,-1),(-1,0),(0,1),(1,0)
```
原题链接：http://codeup.cn/problem.php?cid=100000608&pid=5

### 输入样例
```C++
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6
```

### 输出样例
```C++
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
```

### 代码
```C++
#include<iostream>
using namespace std;
int n,m;
int starti,startj,endi,endj;

int mp[111][111];
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}}; //左上右下
int ans[111][2];
bool flag=0;

void dfs(int i,int j,int sum)
{
	if(i==endi && j==endj)
	{
		cout<<"("<<starti<<","<<startj<<")";
		for(int k=0;k<sum;k++)
		cout<<"->("<<ans[k][0]<<","<<ans[k][1]<<")";
		cout<<endl;
		flag=1;
		return;
	}
	for(int k=0;k<4;k++) //对四个方向进行判断
	{
		int xx=i+dir[k][0];
		int yy=j+dir[k][1];
		if(mp[xx][yy]==1 && xx>=1 && xx<=n && yy>=1 && yy<=m)
		{
			mp[xx][yy]=0;
			ans[sum][0]=xx;
			ans[sum][1]=yy;
			dfs(xx,yy,sum+1);
			mp[xx][yy]=1; //注意回溯
		}
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		cin>>mp[i][j];
	}
	cin>>starti>>startj;
	cin>>endi>>endj;
	if(starti==endi && startj==endj) cout<<"-1";
	else
	{
		dfs(starti,startj,0);
		if(flag==0) cout<<"-1";
	}
	return 0;
}
```
